from flask import Flask, render_template, request
import sqlite3
import os
import subprocess
import platform
from collections import defaultdict
from datetime import datetime, timedelta
import time 

app = Flask(__name__)
app.url_map.strict_slashes = False

def get_db_connection():
    """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚’å–å¾—"""
    conn = sqlite3.connect('vulnapp.db')
    conn.row_factory = sqlite3.Row
    return conn


@app.route('/')
def index():
    """ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸"""
    return render_template('index.html')


@app.route('/products')
def products():
    """å•†å“ä¸€è¦§ãƒšãƒ¼ã‚¸ï¼ˆæ¤œç´¢æ©Ÿèƒ½ä»˜ãï¼‰
    
    è„†å¼±æ€§1: SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
    è„†å¼±æ€§2: XSS (Reflected)
    """
    start_time = time.time()  

    search_query = request.args.get('search', '')
    error_message = None
    products_list = []
    
    conn = get_db_connection()
    
    if search_query:
        try:
            # ğŸš¨ è„†å¼±æ€§1: SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
            query = f"SELECT * FROM products WHERE name LIKE '%{search_query}%' OR description LIKE '%{search_query}%'"
            products_list = conn.execute(query).fetchall()
        except sqlite3.Error as e:
            # ğŸš¨ è„†å¼±æ€§: SQLã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            error_message = f"Database Error: {str(e)}\n\nExecuted Query: {query}"
    else:
        products_list = conn.execute('SELECT * FROM products').fetchall()
    
    conn.close()
    
    execution_time = time.time() - start_time  # â† è¿½åŠ : å®Ÿè¡Œæ™‚é–“ã‚’è¨ˆç®—

    # ğŸš¨ è„†å¼±æ€§2: XSS (Reflected)
    return render_template('products.html',
                          products=products_list,
                          search_query=search_query,
                          error_message=error_message,
                          execution_time=f"{execution_time:.4f}")  


@app.route('/product/<int:product_id>')
def product_detail(product_id):
    """å•†å“è©³ç´°ãƒšãƒ¼ã‚¸ï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºï¼‰
    
    è„†å¼±æ€§3: XSS (Stored)
    """
    conn = get_db_connection()
    
    product = conn.execute('SELECT * FROM products WHERE id = ?', (product_id,)).fetchone()
    
    if not product:
        return 'å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 404
    
    reviews = conn.execute(
        'SELECT * FROM reviews WHERE product_id = ? ORDER BY created_at DESC',
        (product_id,)
    ).fetchall()
    
    conn.close()
    
    # ğŸš¨ è„†å¼±æ€§3: XSS (Stored)
    return render_template('product_detail.html', product=product, reviews=reviews)


@app.route('/product/<int:product_id>/review', methods=['POST'])
def add_review(product_id):
    """ãƒ¬ãƒ“ãƒ¥ãƒ¼æŠ•ç¨¿
    
    è„†å¼±æ€§3: XSS (Stored)
    """
    author = request.form.get('author', 'åŒ¿å')
    comment = request.form.get('comment', '')
    rating = request.form.get('rating', 5)
    
    if not comment:
        return 'ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 400
    
    conn = get_db_connection()
    
    # ğŸš¨ è„†å¼±æ€§3: XSS (Stored)
    conn.execute(
        'INSERT INTO reviews (product_id, author, comment, rating) VALUES (?, ?, ?, ?)',
        (product_id, author, comment, int(rating))
    )
    conn.commit()
    conn.close()
    
    return f'''
    <html>
    <head><meta charset="UTF-8"></head>
    <body>
        <h2>ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŠ•ç¨¿ã—ã¾ã—ãŸ</h2>
        <p><a href="/product/{product_id}">å•†å“ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹</a></p>
    </body>
    </html>
    '''


@app.route('/files')
def file_view():
    """ãƒ•ã‚¡ã‚¤ãƒ«è¡¨ç¤ºæ©Ÿèƒ½
    
    è„†å¼±æ€§4: ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«
    """
    filename = request.args.get('file', '')
    content = None
    error = None
    
    if filename:
        try:
            # ğŸš¨ è„†å¼±æ€§4: ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«
            if filename.startswith('/'):
                file_path = filename
            elif filename.startswith('..'):
                base_dir = os.path.abspath(os.path.join(os.getcwd(), 'static', 'files'))
                file_path = os.path.normpath(os.path.join(base_dir, filename))
            else:
                file_path = os.path.join(os.getcwd(), 'static', 'files', filename)
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
        except Exception as e:
            error = f'ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}'
    
    return render_template('file_view.html', filename=filename, content=content, error=error)


@app.route('/api/info')
def api_info():
    """APIæƒ…å ±ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æ¼æ´©ä¾‹ï¼‰
    
    è„†å¼±æ€§5: æƒ…å ±æ¼æ´©
    """
    import sys
    import flask
    
    # ğŸš¨ è„†å¼±æ€§5: ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®æ¼æ´©
    return {
        'version': '1.0.0',
        'python_version': sys.version,
        'debug': app.debug,
        'database': 'vulnapp.db',
        'database_path': os.path.abspath('vulnapp.db'),
        'framework': 'Flask ' + flask.__version__,
        'server': 'Development Server',
        'host': request.host,
        'cwd': os.getcwd(),
        'endpoints': [str(rule) for rule in app.url_map.iter_rules()]
    }


# ==========================================
# CSRF Vulnerability
# ==========================================
@app.route('/account/settings', methods=['GET', 'POST'])
def account_settings():
    """CSRF Vulnerable - No CSRF token validation"""
    if request.method == 'POST':
        # CSRFãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚§ãƒƒã‚¯ãªã—ï¼ˆæ„å›³çš„ãªè„†å¼±æ€§ï¼‰
        email = request.form.get('email', '')
        username = request.form.get('username', '')
        
        # å®Ÿéš›ã«ã¯DBã«ä¿å­˜ã—ãªã„ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã«ã™ã‚‹ãŸã‚ï¼‰
        message = f"Settings updated! Email: {email}, Username: {username}"
        return render_template('account_settings.html',
                             message=message,
                             current_email=email,
                             current_username=username)
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
    return render_template('account_settings.html',
                         current_email='user@example.com',
                         current_username='testuser')


@app.route('/account/delete', methods=['POST'])
def delete_account():
    """CSRF Vulnerable - Dangerous action without CSRF protection"""
    # CSRFãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚§ãƒƒã‚¯ãªã—ï¼ˆæ„å›³çš„ãªè„†å¼±æ€§ï¼‰
    username = request.form.get('username', 'unknown')
    return f"Account deleted for user: {username} (Simulated)"


# ==========================================
# Command Injection Vulnerability
# ==========================================
@app.route('/tools')
def tools_page():
    """Network tools page"""
    return render_template('tools.html')


@app.route('/tools/ping', methods=['GET', 'POST'])
def ping_tool():
    """Command Injection Vulnerable - Ping tool"""
    output = ""
    host = ""
    
    if request.method == 'POST':
        host = request.form.get('host', '')
    elif request.method == 'GET':
        host = request.args.get('host', '')
    
    if host:
        try:
            # æ„å›³çš„ãªè„†å¼±æ€§: ã‚µãƒ‹ã‚¿ã‚¤ã‚ºãªã—
            if platform.system().lower() == 'windows':
                cmd = f'ping -n 2 {host}'
            else:
                cmd = f'ping -c 2 {host}'
            
            # ã‚·ã‚§ãƒ«çµŒç”±ã§å®Ÿè¡Œï¼ˆå±é™ºï¼‰
            result = subprocess.run(cmd, shell=True, capture_output=True,
                                  text=True, timeout=5)
            output = result.stdout + result.stderr
        except subprocess.TimeoutExpired:
            output = "Command timed out"
        except Exception as e:
            output = f"Error: {str(e)}"
    
    return render_template('tools.html', ping_output=output, ping_host=host)


@app.route('/tools/nslookup', methods=['GET', 'POST'])
def nslookup_tool():
    """Command Injection Vulnerable - DNS lookup tool"""
    output = ""
    domain = ""
    
    if request.method == 'POST':
        domain = request.form.get('domain', '')
    elif request.method == 'GET':
        domain = request.args.get('domain', '')
    
    if domain:
        try:
            # æ„å›³çš„ãªè„†å¼±æ€§: ã‚µãƒ‹ã‚¿ã‚¤ã‚ºãªã—
            if platform.system().lower() == 'windows':
                cmd = f'nslookup {domain}'
            else:
                cmd = f'host {domain}'
            
            # ã‚·ã‚§ãƒ«çµŒç”±ã§å®Ÿè¡Œï¼ˆå±é™ºï¼‰
            result = subprocess.run(cmd, shell=True, capture_output=True,
                                  text=True, timeout=5)
            output = result.stdout + result.stderr
        except subprocess.TimeoutExpired:
            output = "Command timed out"
        except Exception as e:
            output = f"Error: {str(e)}"
    
    return render_template('tools.html', nslookup_output=output, nslookup_domain=domain)


# ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®ãŸã‚ã®ç°¡æ˜“å®Ÿè£…ï¼ˆãƒ¡ãƒ¢ãƒªãƒ™ãƒ¼ã‚¹ï¼‰
review_timestamps = defaultdict(list)

def is_rate_limited(ip_address, max_requests=10, time_window=60):
    """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
    now = datetime.now()
    cutoff = now - timedelta(seconds=time_window)
    
    review_timestamps[ip_address] = [
        ts for ts in review_timestamps[ip_address] if ts > cutoff
    ]
    
    if len(review_timestamps[ip_address]) >= max_requests:
        return True
    
    review_timestamps[ip_address].append(now)
    return False


if __name__ == '__main__':
    # ğŸš¨ è„†å¼±æ€§5: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®æ¬ å¦‚
    app.run(host='0.0.0.0', port=5000, debug=True)
